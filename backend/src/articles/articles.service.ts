// src/articles/articles.service.ts
import {
  Injectable,
  NotFoundException,
  ConflictException,
  InternalServerErrorException,
  BadRequestException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, In, OptimisticLockVersionMismatchError } from 'typeorm';
import { Article } from './entities/article.entity';
import { Tag } from '../tags/entities/tag.entity';
import { CloudinaryService } from '../cloudinary/cloudinary.service';
import { CreateArticleDto } from './dto/create-article.dto';
import { UpdateArticleDto } from './dto/update-article.dto';
import { ArticleUploadService } from './services/article-upload.service';
import { ArticleSeoService } from './services/article-seo.service';
import { Logger } from '@nestjs/common';

@Injectable()
export class ArticlesService {
  private readonly logger = new Logger(ArticlesService.name);

  constructor(
    @InjectRepository(Article)
    private articleRepository: Repository<Article>,
    @InjectRepository(Tag)
    private tagRepository: Repository<Tag>,
    private cloudinaryService: CloudinaryService,
    private articleUploadService: ArticleUploadService,
    private articleSeoService: ArticleSeoService,
  ) {
    // Ë®≠ÂÆöÊó•Ë™åÁ∑®Á¢ºÁÇ∫ UTF-8
    process.env.LANG = 'zh_TW.UTF-8';
    process.env.LC_ALL = 'zh_TW.UTF-8';
  }

  async create(
    createArticleDto: CreateArticleDto,
    coverImage?: Express.Multer.File,
  ) {
    this.logger.log('üöÄ [ArticlesService] ===== Article creation service started =====');
    this.logger.log('üìã [ArticlesService] Received data:', {
      title: createArticleDto.title,
      contentLength: createArticleDto.content?.length || 0,
      coverImageUrl: createArticleDto.coverImageUrl,
      coverImagePublicId: createArticleDto.coverImagePublicId,
      isDraft: createArticleDto.isDraft,
      categoryId: createArticleDto.categoryId,
      tagIds: createArticleDto.tagIds,
      hasCoverImage: !!coverImage,
    });

    let coverImageUploadResult: any = null;
    let contentUploadResult: any = null;

    try {
      // ËôïÁêÜÂ∞ÅÈù¢ÂúñÁâá‰∏äÂÇ≥
      if (coverImage) {
        coverImageUploadResult =
          await this.articleUploadService.uploadCoverImage(coverImage);
      } else if (
        createArticleDto.coverImageUrl &&
        createArticleDto.coverImagePublicId
      ) {
        coverImageUploadResult =
          await this.articleUploadService.checkExistingCoverImage(
            createArticleDto.coverImageUrl,
            createArticleDto.coverImagePublicId,
          );

        if (!coverImageUploadResult) {
          throw new BadRequestException('Cloudinary resource not found');
        }

        // Ê™¢Êü•Ë≥áÊñôÂ∫´ÂîØ‰∏ÄÊÄß
        const duplicate = await this.articleRepository.findOne({
          where: { coverImagePublicId: createArticleDto.coverImagePublicId },
        });

        if (duplicate) {
          throw new ConflictException('coverImagePublicId already exists');
        }
      }

      // ËôïÁêÜÂÖßÂÆπ‰∏äÂÇ≥
      if (createArticleDto.content) {
        contentUploadResult = await this.articleUploadService.uploadContent(
          createArticleDto.content,
        );
      }

      // ËôïÁêÜÊ®ôÁ±§
      const tags = await this.processTags(createArticleDto.tagIds);

      // ËôïÁêÜ SEO Êï∏Êìö
      const seoData = this.articleSeoService.processSeoData(createArticleDto);
      const aeoData = this.articleSeoService.processAeoData(createArticleDto);
      const geoData = this.articleSeoService.processGeoData(createArticleDto);

      // ÂÑ≤Â≠òÂà∞Ë≥áÊñôÂ∫´
      const article = this.articleRepository.create({
        title: createArticleDto.title,
        content: createArticleDto.content,
        coverImageUrl:
          coverImageUploadResult?.secure_url || createArticleDto.coverImageUrl,
        coverImagePublicId:
          coverImageUploadResult?.public_id ||
          createArticleDto.coverImagePublicId,
        contentPublicId: contentUploadResult?.public_id,
        isDraft: createArticleDto.isDraft,
        categoryId: createArticleDto.categoryId,
        tags,
        ...seoData,
        ...aeoData,
        ...geoData,
      });

      const savedArticle = await this.articleRepository.save(article);

      this.logger.log('‚úÖ [ArticlesService] Article created successfully:', savedArticle.id);
      return savedArticle;
    } catch (error) {
      // Ê∏ÖÁêÜÂ§±ÊïóÁöÑ‰∏äÂÇ≥
      if (coverImageUploadResult?.public_id) {
        await this.articleUploadService.cleanupFailedUpload(
          coverImageUploadResult.public_id,
          'image',
        );
      }
      if (contentUploadResult?.public_id) {
        await this.articleUploadService.cleanupFailedUpload(
          contentUploadResult.public_id,
          'raw',
        );
      }

      this.logger.error('‚ùå [ArticlesService] Article creation failed:', error);
      throw error;
    }
  }

  private async processTags(tagIds?: number[]): Promise<Tag[]> {
    if (!tagIds || tagIds.length === 0) {
      this.logger.log('‚ÑπÔ∏è [ArticlesService] No tags to process');
      return [];
    }

    this.logger.log('üè∑Ô∏è [ArticlesService] Looking up tag IDs:', tagIds);
    const tags = await this.tagRepository.findBy({ id: In(tagIds) });
    this.logger.log('‚úÖ [ArticlesService] Found tags count:', tags.length);
    return tags;
  }

  async findAll(query: any = {}, request?: any) {
    this.logger.log('üîç [ArticlesService] Starting articles list query');
    this.logger.log('üîç [ArticlesService] Query parameters:', query);

    // ÂÆöÁæ©Â∏∏ÈáèÔºåÈÅøÂÖçÁ°¨Á∑®Á¢º
    const PUBLISHED_STATUS = false;
    const DRAFT_STATUS = true;

    try {
      const queryBuilder = this.articleRepository
      .createQueryBuilder('article')
      .leftJoinAndSelect('article.category', 'category')
      .leftJoinAndSelect('article.tags', 'tags')
        .orderBy('article.createdAt', 'DESC');

      // Ê™¢Êü•ÊòØÂê¶Êúâ Authorization Ê®ôÈ†≠ÔºàË°®Á§∫ÂèØËÉΩÊòØÁÆ°ÁêÜÂì°Ë´ãÊ±ÇÔºâ
      const hasAuthHeader = request?.headers?.authorization && 
                           request.headers.authorization.startsWith('Bearer ');
      this.logger.log('üîç [ArticlesService] Auth header check:', { 
        hasAuthHeader, 
        authHeader: hasAuthHeader ? 'Bearer ***' : 'None'
      });

      // ËôïÁêÜËçâÁ®øÁãÄÊÖãÁØ©ÈÅ∏
      if (query.isDraft !== undefined) {
        const isDraft = query.isDraft === 'true' || query.isDraft === true;
        queryBuilder.andWhere('article.isDraft = :isDraft', { isDraft });
        this.logger.log('üîç [ArticlesService] Using specified isDraft parameter:', isDraft);
      } else {
        // Ê†πÊìöÊòØÂê¶ÊúâË™çË≠âÊ®ôÈ†≠Ê±∫ÂÆöÊòØÂê¶È°ØÁ§∫ËçâÁ®øÊñáÁ´†
        if (hasAuthHeader) {
          // ÊúâË™çË≠âÊ®ôÈ†≠ÁöÑË´ãÊ±ÇÔºàÂèØËÉΩÊòØÁÆ°ÁêÜÂì°ÔºâÂèØ‰ª•ÁúãÂà∞ÊâÄÊúâÊñáÁ´†
          this.logger.log('üîç [ArticlesService] Auth header detected, returning all articles (including drafts)');
    } else {
          // Ê≤íÊúâË™çË≠âÊ®ôÈ†≠ÁöÑË´ãÊ±ÇÔºàÂÖ¨ÈñãË®™ÂïèÔºâÂè™ËÉΩÁúãÂà∞Â∑≤ÁôºÂ∏ÉÁöÑÊñáÁ´†
          queryBuilder.andWhere('article.isDraft = :isDraft', { isDraft: PUBLISHED_STATUS });
          this.logger.log('üîç [ArticlesService] Public access, returning only published articles');
        }
      }

      // ËôïÁêÜÂàÜÈ†Å
      const page = parseInt(query.page) || 1;
      const limit = parseInt(query.limit) || 10;
      const offset = (page - 1) * limit;

      queryBuilder.skip(offset).take(limit);

      // ËôïÁêÜÂàÜÈ°ûÁØ©ÈÅ∏
      if (query.categoryId) {
        queryBuilder.andWhere('category.id = :categoryId', {
          categoryId: query.categoryId,
        });
      }

      // ËôïÁêÜÊ®ôÁ±§ÁØ©ÈÅ∏
      if (query.tagIds) {
        const tagIds = Array.isArray(query.tagIds)
          ? query.tagIds
          : query.tagIds.split(',').map((id: string) => parseInt(id.trim()));
        queryBuilder.andWhere('tags.id IN (:...tagIds)', { tagIds });
      }

      // ËôïÁêÜÊêúÂ∞ã
      if (query.search) {
        queryBuilder.andWhere(
          '(article.title ILIKE :search OR article.content ILIKE :search)',
          { search: `%${query.search}%` },
        );
      }

      const [data, total] = await queryBuilder.getManyAndCount();

      // È©óË≠â‰∏¶ËôïÁêÜÂ∞ÅÈù¢ÂúñÁâá
      const processedData = await Promise.all(
        data.map(async (article) => {
          if (article.coverImageUrl) {
            const validation = await this.cloudinaryService.validateImageUrl(
              article.coverImageUrl,
              article.category?.name
            );
            
            if (!validation.isValid && validation.fallbackUrl) {
              this.logger.warn('[ArticlesService] Using fallback image', {
                articleId: article.id,
                originalUrl: article.coverImageUrl,
                fallbackUrl: validation.fallbackUrl
              });
              article.coverImageUrl = validation.fallbackUrl;
            }
          }
          return article;
        })
      );

      this.logger.log('‚úÖ [ArticlesService] Articles list query successful');
      this.logger.log('üìä [ArticlesService] Query result statistics:', {
        total,
        page,
        limit,
        returnedCount: processedData.length,
        hasAuthHeader,
      });

      // Ë®òÈåÑÊØèÁØáÊñáÁ´†ÁöÑË©≥Á¥∞‰ø°ÊÅØ
      processedData.forEach((article, index) => {
        this.logger.log(
          `  ${index + 1}. ID: ${article.id}, Title: ${article.title}, isDraft: ${article.isDraft}, Created: ${article.createdAt}, Content Length: ${article.content?.length || 0}, Cover Image: ${article.coverImageUrl || 'None'}, coverImagePublicId: ${article.coverImagePublicId || 'None'}`,
        );
      });

      return {
        data: processedData,
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit),
      };
    } catch (error) {
      this.logger.error('‚ùå [ArticlesService] Articles list query failed:', error);
      throw error;
    }
  }

  generateJsonLdForArticle(article: Article): any {
    return {
      '@context': 'https://schema.org',
      '@type': 'Article',
      headline: article.seoTitle || article.title,
      image: article.coverImageUrl ? [article.coverImageUrl] : [],
      datePublished: article.createdAt?.toISOString?.() || '',
      dateModified: article.updatedAt?.toISOString?.() || '',
      author: {
        '@type': 'Person',
        name: 'WURIDAO',
      },
      description: article.seoDescription || '',
      keywords: article.seoKeywords || '',
      ...(article.aeoFaq &&
      Array.isArray(article.aeoFaq) &&
      article.aeoFaq.length > 0
        ? {
            mainEntityOfPage: {
              '@type': 'WebPage',
              '@id': `https://wuridaostudio.com/articles/${article.id}`,
            },
            faq: article.aeoFaq.map((faq) => ({
              '@type': 'Question',
              name: faq.question,
              acceptedAnswer: {
                '@type': 'Answer',
                text: faq.answer,
              },
            })),
          }
        : {}),
    };
  }

  async findOne(id: number) {
    const article = await this.articleRepository.findOne({
      where: { id },
      relations: ['category', 'tags'],
    });

    if (!article) {
      throw new NotFoundException('Article not found');
    }

    // Â¶ÇÊûúÂÖßÂÆπÊòØ Cloudinary URLÔºåÈúÄË¶ÅÂæû Cloudinary Áç≤ÂèñÂØ¶ÈöõÂÖßÂÆπ
    if (
      article.content &&
      article.content.startsWith('https://res.cloudinary.com')
    ) {
      try {
        // Âæû Cloudinary Áç≤ÂèñÊñáÁ´†ÂÖßÂÆπ
        const normalizeDuplicatedFolder = (url: string): string =>
          url.replace(/(articles\/content\/)(?:articles\/content\/)+/g, '$1');

        const originalUrl = article.content;
        let response = await fetch(originalUrl);
        if (response.ok) {
          article.content = await response.text();
          this.logger.log(
            '[ArticleService][findOne] Content fetched from Cloudinary:',
            article.content.substring(0, 100) + '...',
          );
        } else {
          this.logger.error(
            '[ArticleService][findOne] Failed to fetch content from Cloudinary:',
            originalUrl,
          );
          const normalizedUrl = normalizeDuplicatedFolder(originalUrl);
          if (normalizedUrl !== originalUrl) {
            this.logger.log(
              '[ArticleService][findOne] Retrying with normalized URL:',
              normalizedUrl,
            );
            response = await fetch(normalizedUrl);
            if (response.ok) {
              article.content = await response.text();
              this.logger.log(
                '[ArticleService][findOne] Content fetched after URL normalization:',
                article.content.substring(0, 100) + '...',
              );
            }
          }
        }
      } catch (error) {
        this.logger.error(
          '[ArticleService][findOne] Error fetching content from Cloudinary:',
          error,
        );
      }
    }

    if (article) {
      this.logger.log('[ArticleService][findOne] Query:', {
        id: article.id,
        coverImageUrl: article.coverImageUrl,
        contentLength: article.content?.length || 0,
      });
    }

    // Êñ∞Â¢ûÔºöÁî¢Áîü JSON-LD ÁµêÊßãÂåñË≥áÊñô
    const jsonLd = this.generateJsonLdForArticle(article);

    return { ...article, jsonLd };
  }

  // Áï∞Ê≠•ËºâÂÖ•ÊñáÁ´†ÂÖßÂÆπÔºàÁî®ÊñºÂñÆÁØáÊñáÁ´†Ë©≥ÊÉÖÈ†ÅÈù¢Ôºâ
  async loadArticleContent(articleId: number): Promise<string | null> {
    try {
      const article = await this.articleRepository.findOne({
        where: { id: articleId },
        select: ['id', 'content'],
      });

      if (!article || !article.content) {
        return null;
      }

      // Â¶ÇÊûúÂÖßÂÆπÊòØ Cloudinary URLÔºåÂâáÁï∞Ê≠•ËºâÂÖ•
      if (article.content.startsWith('https://res.cloudinary.com')) {
        this.logger.log(
          `üì• [ArticlesService][loadArticleContent] Áï∞Ê≠•ËºâÂÖ•ÊñáÁ´† ${articleId} ÁöÑ Cloudinary ÂÖßÂÆπ`,
        );

        const normalizeDuplicatedFolder = (url: string): string => {
          return url.replace(
            /(articles\/content\/)(?:articles\/content\/)+/g,
            '$1',
          );
        };

        try {
          const originalUrl = article.content;
          let response = await fetch(originalUrl);

          if (response.ok) {
            const actualContent = await response.text();
            this.logger.log(
              `‚úÖ [ArticlesService][loadArticleContent] ÊñáÁ´† ${articleId} ÂÖßÂÆπËºâÂÖ•ÊàêÂäü (${actualContent.length} Â≠óÁ¨¶)`,
            );
            return actualContent;
          } else {
            // ÂòóË©¶‰øÆÊ≠£ÈáçË§áË≥áÊñôÂ§æ
            const normalizedUrl = normalizeDuplicatedFolder(originalUrl);
            if (normalizedUrl !== originalUrl) {
              response = await fetch(normalizedUrl);
              if (response.ok) {
                const actualContent = await response.text();
                this.logger.log(
                  `‚úÖ [ArticlesService][loadArticleContent] ÊñáÁ´† ${articleId} Á∂ì‰øÆÊ≠£ URL ÂæåÂÖßÂÆπËºâÂÖ•ÊàêÂäü (${actualContent.length} Â≠óÁ¨¶)`,
                );
                return actualContent;
              }
            }

            this.logger.error(
              `‚ùå [ArticlesService][loadArticleContent] ÊñáÁ´† ${articleId} ÂÖßÂÆπËºâÂÖ•Â§±Êïó: ${response.status}`,
            );
            return null;
          }
        } catch (error) {
          this.logger.error(
            `‚ùå [ArticlesService][loadArticleContent] ÊñáÁ´† ${articleId} ÂÖßÂÆπËºâÂÖ•ÊôÇÁôºÁîüÈåØË™§:`,
            error,
          );
          return null;
        }
      }

      // Â¶ÇÊûúÂÖßÂÆπ‰∏çÊòØ Cloudinary URLÔºåÁõ¥Êé•ËøîÂõû
      return article.content;
    } catch (error) {
      this.logger.error(
        `‚ùå [ArticlesService][loadArticleContent] ËºâÂÖ•ÊñáÁ´† ${articleId} ÂÖßÂÆπÊôÇÁôºÁîüÈåØË™§:`,
        error,
      );
      return null;
    }
  }

  async update(
    id: number,
    updateArticleDto: UpdateArticleDto,
    coverImage?: Express.Multer.File,
  ) {
    this.logger.log('üîÑ [ArticlesService] ===== Article update service started =====');
    this.logger.log('üìã [ArticlesService] Update parameters:', {
      id,
      isDraft: updateArticleDto.isDraft,
      title: updateArticleDto.title,
      contentLength: updateArticleDto.content?.length || 0,
      dtoKeys: Object.keys(updateArticleDto),
    });

    const article = await this.findOne(id);
    
    this.logger.log('üìã [ArticlesService] Original article state:', {
      id: article.id,
      title: article.title,
      isDraft: article.isDraft,
    });

    const oldCoverImagePublicId = article.coverImagePublicId;
    const oldContentPublicId = article.contentPublicId;
    let newCoverImageUploadResult: any = null;
    let newContentUploadResult: any = null;

    // ËôïÁêÜÂ∞ÅÈù¢ÂúñÁâáÊõ¥Êñ∞
    if (coverImage) {
      // Ê†πÊìöË¶èÂâá #1ÔºöÂÖà‰∏äÂÇ≥Êñ∞ÂúñÁâá
      newCoverImageUploadResult = await this.cloudinaryService.uploadImage(
        coverImage,
        'articles',
      );
      updateArticleDto.coverImageUrl = newCoverImageUploadResult.secure_url;
      article.coverImagePublicId = newCoverImageUploadResult.public_id;
      this.logger.log(
        '[ArticleService][update] ‰∏äÂÇ≥Êñ∞Â∞ÅÈù¢:',
        newCoverImageUploadResult.secure_url,
      );
    }

    // ËôïÁêÜÊñáÁ´†ÂÖßÂÆπÊõ¥Êñ∞
    if (
      updateArticleDto.content &&
      updateArticleDto.content !== article.content
    ) {
      // Â∞áÊñáÁ´†ÂÖßÂÆπËΩâÊèõÁÇ∫ Buffer
      const contentBuffer = Buffer.from(updateArticleDto.content, 'utf-8');

      newContentUploadResult = await this.cloudinaryService.uploadBuffer(
        contentBuffer,
        `article_content_${Date.now()}.txt`,
        'text/plain',
        'articles/content',
        'raw',
      );
      this.logger.log(
        '[ArticleService][update] Content uploaded to Cloudinary:',
        newContentUploadResult.secure_url,
      );

      // Êõ¥Êñ∞ÂÖßÂÆπ URL Âíå public_id
      updateArticleDto.content = newContentUploadResult.secure_url;
      article.contentPublicId = newContentUploadResult.public_id;
    }

    // ËôïÁêÜÊ®ôÁ±§
    if (updateArticleDto.tagIds) {
      const tags = await this.tagRepository.findBy({
        id: In(updateArticleDto.tagIds),
      });
      article.tags = tags;
    }

    // ËôïÁêÜ SEO Ê¨Ñ‰Ωç
    if (updateArticleDto.seoTitle) article.seoTitle = updateArticleDto.seoTitle;
    if (updateArticleDto.seoDescription)
      article.seoDescription = updateArticleDto.seoDescription;
    if (updateArticleDto.seoKeywords)
      article.seoKeywords = updateArticleDto.seoKeywords;

    // ËôïÁêÜ AEO Ê¨Ñ‰Ωç
    if (updateArticleDto.aeoFaq) {
      const validFaqs = updateArticleDto.aeoFaq.filter(
        (faq) =>
          faq.question &&
          faq.answer &&
          faq.question.trim() !== '' &&
          faq.answer.trim() !== '',
      );
      article.aeoFaq = validFaqs;
      article.aeoFeaturedSnippet = validFaqs[0]?.answer || '';
    }

    // ËôïÁêÜ GEO Ê¨Ñ‰Ωç
    if (updateArticleDto.geoLatitude !== undefined)
      article.geoLatitude = updateArticleDto.geoLatitude;
    if (updateArticleDto.geoLongitude !== undefined)
      article.geoLongitude = updateArticleDto.geoLongitude;
    if (updateArticleDto.geoAddress)
      article.geoAddress = updateArticleDto.geoAddress;
    if (updateArticleDto.geoCity) article.geoCity = updateArticleDto.geoCity;
    if (updateArticleDto.geoPostalCode)
      article.geoPostalCode = updateArticleDto.geoPostalCode;

    // ËôïÁêÜ isDraft Ê¨Ñ‰Ωç - Á¢∫‰øù‰∏çÊúÉË¢´ Object.assign Ë¶ÜËìã
    if (updateArticleDto.isDraft !== undefined) {
      article.isDraft = updateArticleDto.isDraft;
      this.logger.log('[ArticleService][update] Setting isDraft:', updateArticleDto.isDraft);
    }

    // ÂâµÂª∫‰∏ÄÂÄã‰∏çÂåÖÂê´Â∑≤ËôïÁêÜÊ¨Ñ‰ΩçÁöÑ DTO ÂâØÊú¨ÔºåÈÅøÂÖç Object.assign Ë¶ÜËìã
    const { 
      seoTitle, seoDescription, seoKeywords, 
      aeoFaq, 
      geoLatitude, geoLongitude, geoAddress, geoCity, geoPostalCode,
      isDraft,
      ...remainingDto 
    } = updateArticleDto;

    Object.assign(article, remainingDto);

    try {
      // Ê†πÊìöË¶èÂâá #1ÔºöÂÑ≤Â≠òË≥áÊñôÂ∫´
      const updatedArticle = await this.articleRepository.save(article);
      this.logger.log('[ArticleService][update] DB actual write:', {
        id: updatedArticle.id,
        coverImageUrl: updatedArticle.coverImageUrl,
        content: updatedArticle.content,
        isDraft: updatedArticle.isDraft,
      });
      
      this.logger.log('‚úÖ [ArticlesService] ===== Article update service completed =====');
      this.logger.log('üìã [ArticlesService] Updated article state:', {
        id: updatedArticle.id,
        title: updatedArticle.title,
        isDraft: updatedArticle.isDraft,
      });

      // Ê†πÊìöË¶èÂâá #1ÔºöÂ¶ÇÊûúË≥áÊñôÂ∫´ÂÑ≤Â≠òÊàêÂäüÔºåÊâçÊ∏ÖÁêÜËàäÊ™îÊ°à
      if (newCoverImageUploadResult && oldCoverImagePublicId) {
        await this.cloudinaryService.safelyDeleteResource(
          oldCoverImagePublicId,
          'image',
        );
      }
      if (newContentUploadResult && oldContentPublicId) {
        await this.cloudinaryService.safelyDeleteResource(
          oldContentPublicId,
          'raw',
        );
      }

      return updatedArticle;
    } catch (dbError) {
      // Ê†πÊìöË¶èÂâá #1ÔºöÂ¶ÇÊûúË≥áÊñôÂ∫´ÂÑ≤Â≠òÂ§±ÊïóÔºåÊ∏ÖÁêÜÊñ∞‰∏äÂÇ≥ÁöÑÊ™îÊ°à
      if (newCoverImageUploadResult) {
        await this.cloudinaryService.safelyDeleteResource(
          newCoverImageUploadResult.public_id,
          'image',
        );
      }
      if (newContentUploadResult) {
        await this.cloudinaryService.safelyDeleteResource(
          newContentUploadResult.public_id,
          'raw',
        );
      }

      // ËôïÁêÜÊ®ÇËßÄÈéñË°ùÁ™Å
      if (dbError instanceof OptimisticLockVersionMismatchError) {
        throw new ConflictException(
          'The record was modified by another user. Please refresh and try again.',
        );
      }

      throw new InternalServerErrorException(
        'Failed to update article record.',
        { cause: dbError },
      );
    }
  }

  async remove(id: number) {
    const article = await this.findOne(id);

    // Ê†πÊìöË¶èÂâá #1ÔºöÂÖàÊ™¢Êü•‰∏¶Âà™Èô§ Cloudinary Ë≥áÊ∫ê
    if (article.coverImagePublicId) {
      try {
        // Ê™¢Êü•Ë≥áÊ∫êÊòØÂê¶Â≠òÂú®
        const exists = await this.cloudinaryService.checkResourceExists(
          article.coverImagePublicId,
          'image',
        );
        if (exists) {
          await this.cloudinaryService.deleteResource(
            article.coverImagePublicId,
            'image',
          );
          this.logger.log(
            '[ArticleService][remove] Cover image deleted:',
            article.coverImagePublicId,
          );
        } else {
          this.logger.log(
            '[ArticleService][remove] Cover image not found:',
            article.coverImagePublicId,
          );
        }
      } catch (error) {
        this.logger.error(
          '[ArticleService][remove] Error deleting cover image:',
          article.coverImagePublicId,
          error,
        );
        // Âç≥‰Ωø Cloudinary Âà™Èô§Â§±ÊïóÔºå‰πüË¶ÅÂà™Èô§Ë≥áÊñôÂ∫´Ë®òÈåÑ
      }
    }

    if (article.contentPublicId) {
      try {
        // Ê™¢Êü•Ë≥áÊ∫êÊòØÂê¶Â≠òÂú®
        const exists = await this.cloudinaryService.checkResourceExists(
          article.contentPublicId,
          'raw',
        );
        if (exists) {
          await this.cloudinaryService.deleteResource(
            article.contentPublicId,
            'raw',
          );
          this.logger.log(
            '[ArticleService][remove] Content deleted:',
            article.contentPublicId,
          );
        } else {
          this.logger.log(
            '[ArticleService][remove] Content not found:',
            article.contentPublicId,
          );
        }
      } catch (error) {
        this.logger.error(
          '[ArticleService][remove] Error deleting content:',
          article.contentPublicId,
          error,
        );
        // Âç≥‰Ωø Cloudinary Âà™Èô§Â§±ÊïóÔºå‰πüË¶ÅÂà™Èô§Ë≥áÊñôÂ∫´Ë®òÈåÑ
      }
    }

    // Ê†πÊìöË¶èÂâá #1ÔºöÁÑ∂ÂæåÂÜçÂà™Èô§Ë≥áÊñôÂ∫´Ë®òÈåÑ
    await this.articleRepository.remove(article);

    return { message: 'Article deleted' };
  }
}
